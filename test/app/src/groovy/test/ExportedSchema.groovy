package test

import groovy.transform.CompileStatic
import groovy.transform.EqualsAndHashCode
import groovy.transform.ToString

/**
 * Represents all of the create and alter (but not drop) statements from schema
 * DDL generated by the schema-export command. The command itself isn't run,
 * but the same Hibernate API is used directly (in SchemaExporter).
 *
 * @author <a href='mailto:burt_beckwith@hms.harvard.edu'>Burt Beckwith</a>
 */
@CompileStatic
@EqualsAndHashCode(excludes='create')
@ToString(includeNames=true, includePackage=false)
class ExportedSchema extends AbstractSqlType {

	Collection<Sequence> sequences = []
	Collection<Table> tables = []
	Map<String, Table> tablesByName = [:]

	ExportedSchema(String create) {
		super(create)
	}

	Table table(String name, String schema = null) {
		tablesByName[(schema ? schema + '.' + name : name).toUpperCase()]
	}

	ExportedSchema leftShift(Table table) {
		String key = table.fullName().toUpperCase()

		assert !tablesByName.containsKey(key)

		tablesByName[key] = table
		tables << table

		for (name in table.primaryKeyColumns) {
			assert table.column(name)
			table.column(name).nullable = false
			table.column(name).unique = true // not correct for compound pk
		}

		this
	}

	/**
	 * Operator overload to support adding a Sequence with <<
	 *
	 * @return this for chaining
	 */
	ExportedSchema leftShift(Sequence sequence) {
		assert !sequences.contains(sequence)

		sequences << sequence

		this
	}

	/**
	 * Operator overload to support adding a ForeignKey with <<
	 *
	 * @return this for chaining
	 */
	ExportedSchema leftShift(ForeignKey fk) {
		Table table = tablesByName[fk.table.toUpperCase()]
		assert table

		table << fk

		this
	}

	/**
	 * Operator overload to support adding an Index with <<
	 *
	 * @return this for chaining
	 */
	ExportedSchema leftShift(Index index) {
		Table table = tablesByName[index.table.toUpperCase()]
		assert table

		table << index

		this
	}

	String asSql() {
		StringBuilder sb = new StringBuilder()

		for (Table t in tables) {
			sb << t.asSql() << '\n'
		}

		for (Sequence s in sequences) {
			sb << s.asSql() << ';\n'
		}

		sb
	}
}
